class ConwayHandler : EventHandler
{
	const TICS_PER_SECOND = 35;
	const UPDATE_FREQUENCY_SECONDS = 3;
	
	const GRID_SIZE = 5;
	bool board[GRID_SIZE][GRID_SIZE];
	bool boardNext[GRID_SIZE][GRID_SIZE];
	
	int lastUpdateTime;
	
	ConwayPlayer player;
	
	override void WorldLoaded(WorldEvent e) {
		Console.Printf("Hello World!");
		player = FindPlayer();
		InitBoard();
		PrintBoard();
	}
	
    override void WorldTick()
    {
		let timeSeconds = level.time / TICS_PER_SECOND; // int division chops decimal
		//Console.Printf("timeSeconds=" .. timeSeconds .. " lastUpdate=" .. lastUpdateTime .. "dt=" .. timeSeconds - lastUpdateTime);
		if (timeSeconds - lastUpdateTime >= UPDATE_FREQUENCY_SECONDS) {
			lastUpdateTime = timeSeconds;
			Console.Printf("Updating, timeSeconds=" .. timeSeconds);
			NextGen();
			PrintBoard();
		}
	}
	
	ConwayPlayer FindPlayer() {
	    ThinkerIterator playerFinder = ThinkerIterator.Create("ConwayPlayer");
        let playerResult = ConwayPlayer(playerFinder.Next());
		if (playerResult == null) {
			Console.Printf("Error! No player found.");
		} else {
			Console.Printf("Found player: " .. playerResult);
		}
		return playerResult;
	}
	
	void InitBoard() {
		//Glider
		board[0][1] = true;
		board[1][2] = true;
		board[2][0] = true;
		board[2][1] = true;
		board[2][2] = true;
		
		//Spinner
		// board[1][1] = true;
		// board[1][2] = true;
		// board[1][3] = true;
	}
	
	// This basically hashes two positive numbers into a unique third number, see https://stackoverflow.com/a/13871379/350761
	int SzudzikPair(int a, int b) {
		return a >= b ? a * a + a + b : a + b * b;
	}
	
	Actor FindActor(int tid) {
		let actorFinder = ActorIterator.Create(tid);
        return actorFinder.Next(); 
	}
	
	Vector3 GetWorldPosForGrid(int x, int y) {
		let scale = 100;
		return (player.pos.x + (x * scale), player.pos.y + (y * scale), player.pos.z);
	}
	
	bool IsDead(Actor actor) {
		return actor.InStateSequence(actor.CurState, actor.ResolveState("XDeath"))
			|| actor.InStateSequence(actor.CurState, actor.ResolveState("Death"));
	}
	
	void SpawnOrRessurectCell(int x, int y) {
		let cellTid = SzudzikPair(x, y);
		let cellActor = FindActor(cellTid);
		//Console.Printf("Spawn Cell tid:" .. cellTid);
		if (cellActor == null) {
			Console.Printf("SPAWN:SPAWN " .. cellTid);
			cellActor = player.Spawn("DoomImp", GetWorldPosForGrid(x, y), NO_REPLACE);
			cellActor.ChangeTid(cellTid);
		} else {
			// Raise if dead, otherwise do nothing
			if (IsDead(cellActor)) {
				Console.Printf("SPAWN:REZ " .. cellTid);
				cellActor.SetState(cellActor.ResolveState("Raise"));
				//Thing_Raise(cellTid, true);
			} else {
				Console.Printf("SPAWN:NOP " .. cellTid);
			}
		}
		cellActor.bFRIENDLY = true;
		cellActor.bSTANDSTILL = true;
		cellActor.bINVULNERABLE = true;
		//Thing_Deactivate(cellTid);
	}
	
	void KillCell(int x, int y) {
		let cellTid = SzudzikPair(x, y);
		let cellActor = FindActor(cellTid);
		if (cellActor != null) {
			//Thing_Destroy(cellTid);
			if (!IsDead(cellActor)) {
				cellActor.SetState(cellActor.ResolveState("XDeath"));
				Console.Printf("KillCell tid:" .. cellTid);
			}
		}
	}
	
	// override void WorldThingRevived(WorldEvent e) {
		// Console.Printf("WorldThingRevived:" .. e.Thing);
		// e.Thing.bDormant = true;
	// }
	
	void PrintBoard() {
		Console.Printf("======NEW GENERATION=====");
		for (let x = 0; x < GRID_SIZE; x++) {
			let l = "";
			for (let y = 0; y < GRID_SIZE; y++) {
				if (board[x][y]) {
					l = l .. "X";
					SpawnOrRessurectCell(x, y);
				} else {
					l = l .. "_";
					KillCell(x, y);
				}
			}
			Console.Printf(l);
		}
	}
	
	void ClearBoardNext() {
		for(let i = 0; i < GRID_SIZE; ++i) {
			for(let j = 0; j < GRID_SIZE; ++j) {
				boardNext[i][j] = false;
			}
		}
	}
	
	void CopyNextToCurrent() {
		for(let i = 0; i < GRID_SIZE; ++i) {
			for(let j = 0; j < GRID_SIZE; ++j) {
				board[i][j] = boardNext[i][j];
			}
		}
	}
	
	// Implementation of life rules based on https://rosettacode.org/wiki/Conway%27s_Game_of_Life#JavaScript
	void NextGen() {
		ClearBoardNext();
		
		for (let x = 0; x < GRID_SIZE; x++) {
			for (let y = 0; y < GRID_SIZE; y++) {
				let n = 0;
				for (let dx = -1; dx <= 1; dx++) {
					for (let dy = -1; dy <= 1; dy++) {
						if ( dx == 0 && dy == 0) {
						} else if (x+dx < GRID_SIZE
								&& y+dy < GRID_SIZE
								&& board[x+dx][y+dy]) {
							n++;
						}
					}
				}
				let c = board[x][y];
				switch (n) {
					case 0:
					case 1:
						c = 0;
						break;
					case 2:
						break;
					case 3:
						c = 1;
						break;
					default:
						c = 0;
				}
				boardNext[x][y] = c;
			}
		}
		
		CopyNextToCurrent();
	}
}