class ConwayHandler : EventHandler
{
	const TICS_PER_SECOND = 35;
	const UPDATE_FREQUENCY_SECONDS = 2;
	
	const GRID_SIZE = 5;
	bool board[GRID_SIZE][GRID_SIZE];
	bool boardNext[GRID_SIZE][GRID_SIZE];
	
	int lastUpdateTime;
	
	ConwayPlayer player;
	
	override void WorldLoaded(WorldEvent e) {
		Console.Printf("Hello World!");
		player = FindPlayer();
		InitBoard();
		PrintBoard();
	}
	
    override void WorldTick()
    {
		let timeSeconds = level.time / TICS_PER_SECOND; // int division chops decimal
		//Console.Printf("timeSeconds=" .. timeSeconds .. " lastUpdate=" .. lastUpdateTime .. "dt=" .. timeSeconds - lastUpdateTime);
		if (timeSeconds - lastUpdateTime >= UPDATE_FREQUENCY_SECONDS) {
			lastUpdateTime = timeSeconds;
			Console.Printf("Updating, timeSeconds=" .. timeSeconds);
			NextGen();
			PrintBoard();
		}
	}
	
	ConwayPlayer FindPlayer() {
	    ThinkerIterator playerFinder = ThinkerIterator.Create("ConwayPlayer");
        let playerResult = ConwayPlayer(playerFinder.Next());
		if (playerResult == null) {
			Console.Printf("Error! No player found.");
		} else {
			Console.Printf("Found player: " .. playerResult);
		}
		return playerResult;
	}
	
	void InitBoard() {
		//Try to make a glider
		board[0][1] = true;
		board[1][2] = true;
		board[2][0] = true;
		board[2][1] = true;
		board[2][2] = true;
	}
	
	// This basically hashes two numbers into a unique third number, see https://stackoverflow.com/a/13871379/350761
	int SzudzikPair(int a, int b) {
		return a >= b ? a * a + a + b : a + b * b;
	}
	
	void RessurectCell(int x, int y) {
		let cellActor = player.Spawn("DoomImp", (player.pos.x + (x * 100), player.pos.y + (y * 100), player.pos.z), NO_REPLACE);
		cellActor.ChangeTid(SzudzikPair(x, y));
		cellActor.bFriendly = true;
		Console.Printf("CellActor tid:" .. cellActor.tid);
	}
	
	void KillCell(int x, int y) {
		let targetTid = SzudzikPair(x, y);
		Console.Printf("KillCell tid:" .. targetTid);
		Thing_Destroy(targetTid);
	}
	
	void PrintBoard() {
		for (let x = 0; x < GRID_SIZE; x++) {
			let l = "";
			for (let y = 0; y < GRID_SIZE; y++) {
				if (board[x][y]) {
					l = l .. "X";
					RessurectCell(x, y);
				} else {
					l = l .. "_";
					KillCell(x, y);
				}
			}
			Console.Printf(l);
		}
	}
	
	void ClearBoardNext() {
		for(let i = 0; i < GRID_SIZE; ++i) {
			for(let j = 0; j < GRID_SIZE; ++j) {
				boardNext[i][j] = false;
			}
		}
	}
	
	void CopyNextToCurrent() {
		for(let i = 0; i < GRID_SIZE; ++i) {
			for(let j = 0; j < GRID_SIZE; ++j) {
				board[i][j] = boardNext[i][j];
			}
		}
	}
	
	// Implementation of life rules based on https://rosettacode.org/wiki/Conway%27s_Game_of_Life#JavaScript
	void NextGen() {
		ClearBoardNext();
		
		for (let x = 0; x < GRID_SIZE; x++) {
			for (let y = 0; y < GRID_SIZE; y++) {
				let n = 0;
				for (let dx = -1; dx <= 1; dx++) {
					for (let dy = -1; dy <= 1; dy++) {
						if ( dx == 0 && dy == 0) {
						} else if (x+dx < GRID_SIZE
								&& y+dy < GRID_SIZE
								&& board[x+dx][y+dy]) {
							n++;
						}
					}
				}
				let c = board[x][y];
				switch (n) {
					case 0:
					case 1:
						c = 0;
						break;
					case 2:
						break;
					case 3:
						c = 1;
						break;
					default:
						c = 0;
				}
				boardNext[x][y] = c;
			}
		}
		
		CopyNextToCurrent();
	}
}